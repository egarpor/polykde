# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Euler step for density ridge estimation
#'
#' @inheritParams kde_polysph
#' @inheritParams proj_grad_kde_polysph
#' @param h_euler vector of size \code{r} with the advance steps in the Euler
#' method. Set internally as \code{h} if not provided.
#' @param N maximum number of Euler iterations. Defaults to \code{1e3}.
#' @param eps convergence tolerance. Defaults to \code{1e-5}.
#' @param keep_paths keep the Euler paths to the ridge? Defaults to
#' \code{FALSE}.
#' @param show_prog display a progress bar for \code{x}? Defaults to
#' \code{TRUE}.
#' @param show_prog_j display a progress bar for \code{N}? Defaults to
#' \code{FALSE}.
#' @export
euler_ridge <- function(x, X, d, h, h_euler = as.numeric( c()), weights = as.numeric( c()), wrt_unif = FALSE, normalized = TRUE, norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0, N = 1e3L, eps = 1e-5, keep_paths = FALSE, proj_alt = TRUE, fix_u1 = TRUE, sparse = FALSE, show_prog = TRUE, show_prog_j = FALSE) {
    .Call(`_polykde_euler_ridge`, x, X, d, h, h_euler, weights, wrt_unif, normalized, norm_x, norm_X, kernel, kernel_type, k, N, eps, keep_paths, proj_alt, fix_u1, sparse, show_prog, show_prog_j)
}

#' @title Gradient and Hessian of the polyspherical kde
#'
#' @inheritParams kde_polysph
#' @param projected compute the \emph{projected} gradient and Hessian that
#' accounts for the radial projection? Defaults to \code{TRUE}.
#' @param proj_alt alternative projection. Defaults to \code{TRUE}.
#' @param norm_grad_hess normalize the gradient and Hessian dividing by the
#' kde? Defaults to \code{FALSE}.
#' @export
grad_hess_kde_polysph <- function(x, X, d, h, weights = as.numeric( c()), projected = TRUE, proj_alt = TRUE, norm_grad_hess = FALSE, log = FALSE, wrt_unif = FALSE, normalized = TRUE, norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0) {
    .Call(`_polykde_grad_hess_kde_polysph`, x, X, d, h, weights, projected, proj_alt, norm_grad_hess, log, wrt_unif, normalized, norm_x, norm_X, kernel, kernel_type, k)
}

#' @title Projected gradient of the polyspherical kde
#'
#' @inheritParams kde_polysph
#' @inheritParams grad_hess_kde_polysph
#' @param fix_u1 ensure the \eqn{u_1} vector is different from \eqn{x}?
#' Prevents the Euler algorithm to "surf the ridge". Defaults to \code{TRUE}.
#' @param sparse use a sparse eigendecomposition of the Hessian? Defaults to
#' \code{FALSE}.
#' @export
proj_grad_kde_polysph <- function(x, X, d, h, weights = as.numeric( c()), wrt_unif = FALSE, normalized = TRUE, norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0, proj_alt = TRUE, fix_u1 = TRUE, sparse = FALSE) {
    .Call(`_polykde_proj_grad_kde_polysph`, x, X, d, h, weights, wrt_unif, normalized, norm_x, norm_X, kernel, kernel_type, k, proj_alt, fix_u1, sparse)
}

#' @title Polyspherical kernel density estimator
#'
#' @param x a matrix of size \code{c(nx, sum(d) + r)} with the evaluation
#' points.
#' @param X a matrix of size \code{c(n, sum(d) + r)} with the sample.
#' @param d dimensions vector, of size \code{r}.
#' @param h bandwidth vector, of size \code{r}.
#' @param weights weights for each observation. If provided, a vector of size
#' \code{n} with the weights for multiplying each kernel. If not provided,
#' set internally to \code{rep(1 / n, n)}, which gives the standard estimator.
#' @param log compute the logarithm of the kde? Defaults to \code{FALSE}.
#' @param wrt_unif flag to return a pdf with respect to the uniform measure.
#' If \code{FALSE} (default), the pdf is with respect to the Lebesgue measure.
#' @param normalized flag to compute the normalizing constant of the kernel
#' and include it in the kernel density estimator. Defaults to \code{TRUE}.
#' @param intrinsic use the intrinsic distance, instead of the
#' extrinsic-chordal distance, in the kernel? Defaults to \code{FALSE}.
#' @param norm_x,norm_X ensure a normalization of the data? Defaults to
#' \code{FALSE}.
#' @param kernel kernel employed: \code{1} for vMF (default); \code{2}
#' for Epa, \eqn{L(t) = (1 - t)1_{\{0 \le t \le 1\}}}; \code{3} for softplus.
#' @param kernel_type type of kernel employed: \code{1} for product kernel
#' (default); \code{2} for spherically symmetric kernel.
#' @param k softplus kernel parameter. Defaults to \code{10.0}.
#' @export
kde_polysph <- function(x, X, d, h, weights = as.numeric( c()), log = FALSE, wrt_unif = FALSE, normalized = TRUE, intrinsic = FALSE, norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0) {
    .Call(`_polykde_kde_polysph`, x, X, d, h, weights, log, wrt_unif, normalized, intrinsic, norm_x, norm_X, kernel, kernel_type, k)
}

#' @rdname kde_polysph
#' @export
log_cv_kde_polysph <- function(X, d, h, weights = as.numeric( c()), wrt_unif = FALSE, normalized = TRUE, intrinsic = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0) {
    .Call(`_polykde_log_cv_kde_polysph`, X, d, h, weights, wrt_unif, normalized, intrinsic, norm_X, kernel, kernel_type, k)
}

#' @title Stable computation of the softplus function
#'
#' @inheritParams softplus
#' @examples
#' curve(log(sfp(rbind(5 * (1 - x)))), from = -10, to = 10)
#' @export
sfp <- function(t) {
    .Call(`_polykde_sfp`, t)
}

#' @title Polyspherical projection
#'
#' @inheritParams kde_polysph
#' @param ind_dj 0-based index separating the spheres. Computed using
#' \code{\link{comp_ind_dj}}.
#' @export
proj_polysph <- function(x, ind_dj) {
    .Call(`_polykde_proj_polysph`, x, ind_dj)
}

#' @title Polyspherical distance
#'
#' @param x a matrix of size \code{c(n, sum(d) + r)}.
#' @param y either a matrix of the same dimension of \code{x} or a vector of
#' length \code{sum(d) + r}.
#' @inheritParams proj_polysph
#' @param norm_x,norm_y ensure a normalization of the data?
#' @param std standardize distance to \eqn{[0,1]}? Uses that the maximum
#' distance is \eqn{\sqrt{r}\pi}. Defaults to \code{TRUE}.
#' @export
dist_polysph <- function(x, y, ind_dj, norm_x = FALSE, norm_y = FALSE, std = TRUE) {
    .Call(`_polykde_dist_polysph`, x, y, ind_dj, norm_x, norm_y, std)
}

#' @title Cross polyspherical distance
#'
#' @inheritParams dist_polysph
#' @param y either a matrix of the same dimension of \code{x} or a vector of
#' length \code{sum(d) + r}.
#' @export
dist_polysph_cross <- function(x, y, ind_dj, norm_x = FALSE, norm_y = FALSE, std = TRUE) {
    .Call(`_polykde_dist_polysph_cross`, x, y, ind_dj, norm_x, norm_y, std)
}

#' @title Compute cube \eqn{X_i \diamond X_i'}
#'
#' @inheritParams kde_polysph
#' @inheritParams proj_polysph
#' @export
diamond_crossprod <- function(X, ind_dj) {
    .Call(`_polykde_diamond_crossprod`, X, ind_dj)
}

#' @title Symmetrize a matrix A with (A+A')/2
#'
#' @param A matrix.
#' @param add return simply the addition A + A'? Defaults to \code{FALSE}
#' @export
s <- function(A, add = FALSE) {
    .Call(`_polykde_s`, A, add)
}

#' @title Projection matrices P and A
#'
#' @description The \eqn{jj}-block of \eqn{P} is \eqn{I_{d_j} - x_j x_j'}. The
#' \eqn{jj}-block of \eqn{A} is \eqn{(x_j' * v_j) * I_{d_j}}.
#'
#' @param x,v row vectors of size \code{sum(d) + r}.
#' @inheritParams proj_polysph
#' @param orth return the orthogonal complement of \eqn{P}, \eqn{I - P}?
#' @export
AP <- function(x, v, ind_dj, orth = FALSE) {
    .Call(`_polykde_AP`, x, v, ind_dj, orth)
}

