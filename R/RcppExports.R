# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Euler step for density ridge estimation
#'
#' @description TODO
#'
#' @inheritParams kde_polysph
#' @inheritParams proj_grad_kde_polysph
#' @param h_euler vector of size \code{r} with the advance steps in the Euler
#' method. Set internally as \code{h} if not provided.
#' @param N maximum number of Euler iterations. Defaults to \code{1e3}.
#' @param eps convergence tolerance. Defaults to \code{1e-5}.
#' @param keep_paths keep the Euler paths to the ridge? Defaults to
#' \code{FALSE}.
#' @param show_prog display a progress bar for \code{x}? Defaults to
#' \code{TRUE}.
#' @param show_prog_j display a progress bar for \code{N}? Defaults to
#' \code{FALSE}.
#' @return TODO
#' @examples
#' # TODO
#' @export
euler_ridge <- function(x, X, d, h, h_euler = as.numeric( c()), weights = as.numeric( c()), wrt_unif = FALSE, normalized = TRUE, norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0, N = 1e3L, eps = 1e-5, keep_paths = FALSE, proj_alt = TRUE, fix_u1 = TRUE, sparse = FALSE, show_prog = TRUE, show_prog_j = FALSE) {
    .Call(`_polykde_euler_ridge`, x, X, d, h, h_euler, weights, wrt_unif, normalized, norm_x, norm_X, kernel, kernel_type, k, N, eps, keep_paths, proj_alt, fix_u1, sparse, show_prog, show_prog_j)
}

#' @title Gradient and Hessian of the polyspherical kde
#'
#' @description TODO
#'
#' @inheritParams kde_polysph
#' @param projected compute the \emph{projected} gradient and Hessian that
#' accounts for the radial projection? Defaults to \code{TRUE}.
#' @param proj_alt alternative projection. Defaults to \code{TRUE}.
#' @param norm_grad_hess normalize the gradient and Hessian dividing by the
#' kde? Defaults to \code{FALSE}.
#' @return TODO
#' @examples
#' # TODO
#' @export
grad_hess_kde_polysph <- function(x, X, d, h, weights = as.numeric( c()), projected = TRUE, proj_alt = TRUE, norm_grad_hess = FALSE, log = FALSE, wrt_unif = FALSE, normalized = TRUE, norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0) {
    .Call(`_polykde_grad_hess_kde_polysph`, x, X, d, h, weights, projected, proj_alt, norm_grad_hess, log, wrt_unif, normalized, norm_x, norm_X, kernel, kernel_type, k)
}

#' @title Projected gradient of the polyspherical kde
#'
#' @description TODO
#'
#' @inheritParams kde_polysph
#' @inheritParams grad_hess_kde_polysph
#' @param fix_u1 ensure the \eqn{u_1} vector is different from \eqn{x}?
#' Prevents the Euler algorithm to "surf the ridge". Defaults to \code{TRUE}.
#' @param sparse use a sparse eigendecomposition of the Hessian? Defaults to
#' \code{FALSE}.
#' @return TODO
#' @examples
#' # TODO
proj_grad_kde_polysph <- function(x, X, d, h, weights = as.numeric( c()), wrt_unif = FALSE, normalized = TRUE, norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0, proj_alt = TRUE, fix_u1 = TRUE, sparse = FALSE) {
    .Call(`_polykde_proj_grad_kde_polysph`, x, X, d, h, weights, wrt_unif, normalized, norm_x, norm_X, kernel, kernel_type, k, proj_alt, fix_u1, sparse)
}

#' @title Polyspherical kernel density estimator
#'
#' @description Computes the kernel density estimator for data on the
#' polysphere \eqn{\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}}.
#' Given a sample \eqn{\boldsymbol{X}_1,\ldots,\boldsymbol{X}_n}, this
#' estimator is
#' \deqn{\hat{f}(\boldsymbol{x};\boldsymbol{h})=\sum_{i=1}^n
#' L_{\boldsymbol{h}}(\boldsymbol{x},\boldsymbol{X}_i)}
#' for a kernel \eqn{L} and a vector of bandwidths \eqn{\boldsymbol{h}}.
#'
#' @param x a matrix of size \code{c(nx, sum(d) + r)} with the evaluation
#' points.
#' @param X a matrix of size \code{c(n, sum(d) + r)} with the sample.
#' @param d dimensions vector, of size \code{r}.
#' @param h bandwidth vector, of size \code{r}.
#' @param weights weights for each observation. If provided, a vector of size
#' \code{n} with the weights for multiplying each kernel. If not provided,
#' set internally to \code{rep(1 / n, n)}, which gives the standard estimator.
#' @param log compute the logarithm of the density? Defaults to \code{FALSE}.
#' @param wrt_unif flag to return a density with respect to the uniform
#' measure. If \code{FALSE} (default), the density is with respect to the
#' Lebesgue measure.
#' @param normalized flag to compute the normalizing constant of the kernel
#' and include it in the kernel density estimator. Defaults to \code{TRUE}.
#' @param intrinsic use the intrinsic distance, instead of the
#' extrinsic-chordal distance, in the kernel? Defaults to \code{FALSE}.
#' @param norm_x,norm_X ensure a normalization of the data? Defaults to
#' \code{FALSE}.
#' @param kernel kernel employed: \code{1} for vMF (default); \code{2}
#' for Epa, \eqn{L(t) = (1 - t)1_{\{0 \le t \le 1\}}}; \code{3} for softplus.
#' @param kernel_type type of kernel employed: \code{1} for product kernel
#' (default); \code{2} for spherically symmetric kernel.
#' @param k softplus kernel parameter. Defaults to \code{10.0}.
#' @return A column vector of size \code{c(nx, 1)}.
#' @examples
#' # TODO
#' @export
kde_polysph <- function(x, X, d, h, weights = as.numeric( c()), log = FALSE, wrt_unif = FALSE, normalized = TRUE, intrinsic = FALSE, norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0) {
    .Call(`_polykde_kde_polysph`, x, X, d, h, weights, log, wrt_unif, normalized, intrinsic, norm_x, norm_X, kernel, kernel_type, k)
}

#' @title Cross-validation for the polyspherical kernel density estimator
#'
#' @description Computes \eqn{\log
#' \hat{f}_{-i}(\boldsymbol{X}_i;\boldsymbol{h})}, \eqn{i=1,\ldots,n}.
#'
#' @inheritParams kde_polysph
#' @return A column vector of size \code{c(n, 1)}.
#' @examples
#' # TODO
#' @export
log_cv_kde_polysph <- function(X, d, h, weights = as.numeric( c()), wrt_unif = FALSE, normalized = TRUE, intrinsic = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10.0) {
    .Call(`_polykde_log_cv_kde_polysph`, X, d, h, weights, wrt_unif, normalized, intrinsic, norm_X, kernel, kernel_type, k)
}

#' @title Stable computation of the softplus function
#'
#' @description Computes the softplus function \eqn{\log(1+e^{t})} in a
#' numerically stable way for large absolute values of \eqn{t}.
#'
#' @inheritParams softplus
#' @return The softplus function evaluated at \code{t}.
#' @examples
#' curve(log(polykde:::sfp(rbind(5 * (1 - x)))), from = -10, to = 10)
#' @keywords internal
sfp <- function(t) {
    .Call(`_polykde_sfp`, t)
}

#' @title Projection onto the polysphere
#'
#' @description Projects points on \eqn{\mathbb{R}^{d_1 + \cdots + d_r + r}}
#' onto the polysphere \eqn{S^{d_1} \times \cdots \times S^{d_r}} by
#' normalizing each block of \eqn{d_j} coordinates.
#'
#' @param x a matrix of size \code{c(n, sum(d) + r)}.
#' @param ind_dj \code{0}-based index separating the blocks of spheres that
#' is computed with \code{\link{comp_ind_dj}}.
#' @return A matrix of size \code{c(n, sum(d) + r)} with the projected points.
#' @examples
#' # Example on (S^1)^2
#' d <- c(1, 1)
#' x <- rbind(c(2, 0, 1, 1))
#' polykde:::proj_polysph(x, ind_dj = comp_ind_dj(d))
#' @keywords internal
proj_polysph <- function(x, ind_dj) {
    .Call(`_polykde_proj_polysph`, x, ind_dj)
}

#' @title Polyspherical distance
#'
#' @description Computation of the distance between points \eqn{\boldsymbol{x}}
#' and \eqn{\boldsymbol{y}} on the polysphere
#' \eqn{\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}}:
#' \deqn{\sqrt{\sum_{j=1}^r
#' d_{\mathcal{S}^{d_j}}(\boldsymbol{x}_j, \boldsymbol{y}_j)^2},}
#' where \eqn{d_{\mathcal{S}^{d_j}}(\boldsymbol{x}_j, \boldsymbol{y}_j)=
#' \cos^{-1}(\boldsymbol{x}_j' \boldsymbol{y}_j)}.
#'
#' @inheritParams proj_polysph
#' @param y either a matrix of size \code{c(m, sum(d) + r)} or a vector of
#' length \code{sum(d) + r}.
#' @inheritParams proj_polysph
#' @param norm_x,norm_y ensure a normalization of the data?
#' @param std standardize distance to \eqn{[0,1]}? Uses that the maximum
#' distance is \eqn{\sqrt{r}\pi}. Defaults to \code{TRUE}.
#' @return
#' \itemize{
#' \item{\code{dist_polysph}: a vector of size \code{n} with the distances
#' between \code{x} and \code{y}.}
#' \item{\code{dist_polysph_matrix}: a matrix of size \code{c(n, n)} with the
#' pairwise distances of \code{x}.}
#' \item{\code{dist_polysph_cross}: a matrix of distances of size
#' \code{c(n, m)} with the cross distances between \code{x} and \code{y}.}
#' }
#' @examples
#' # Example on S^2 x S^3 x S^1
#' d <- c(2, 3, 1)
#' ind_dj <- comp_ind_dj(d)
#' n <- 3
#' x <- r_unif_polysph(n = n, d = d)
#' y <- r_unif_polysph(n = n, d = d)
#'
#' # Distances of x to y
#' dist_polysph(x = x, y = y, ind_dj = ind_dj, std = FALSE)
#' dist_polysph(x = x, y = y[1, , drop = FALSE], ind_dj = ind_dj, std = FALSE)
#'
#' # Pairwise distance matrix of x
#' dist_polysph_matrix(x = x, ind_dj = ind_dj, std = FALSE)
#'
#' # Cross distances between x and y
#' dist_polysph_cross(x = x, y = y, ind_dj = ind_dj, std = FALSE)
#' @export
dist_polysph <- function(x, y, ind_dj, norm_x = FALSE, norm_y = FALSE, std = TRUE) {
    .Call(`_polykde_dist_polysph`, x, y, ind_dj, norm_x, norm_y, std)
}

#' @rdname dist_polysph
#' @export
dist_polysph_cross <- function(x, y, ind_dj, norm_x = FALSE, norm_y = FALSE, std = TRUE) {
    .Call(`_polykde_dist_polysph_cross`, x, y, ind_dj, norm_x, norm_y, std)
}

#' @title Diamond cross-product
#'
#' @description Given a matrix \eqn{\boldsymbol{X}} whose \eqn{n} rows are on a
#' polysphere \eqn{\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}},
#' the function computes the cube whose rows are
#' \eqn{\boldsymbol{X}_i \diamond \boldsymbol{X}_i'}, \eqn{i = 1, \ldots, n},
#' and \eqn{\diamond} is a block-by-block product.
#'
#' @inheritParams kde_polysph
#' @inheritParams proj_polysph
#' @return An array of size \code{c(nrow(X), ncol(X), ncol(X))}.
#' @examples
#' d <- c(1, 2)
#' X <- r_unif_polysph(n = 2, d = d)
#' polykde:::diamond_crossprod(X = X, ind_dj = comp_ind_dj(d))
#' @keywords internal
diamond_crossprod <- function(X, ind_dj) {
    .Call(`_polykde_diamond_crossprod`, X, ind_dj)
}

#' @title Symmetrize a matrix
#'
#' @description Symmetrizes a matrix \eqn{\boldsymbol{A}} by returning
#' \eqn{(\boldsymbol{A} + \boldsymbol{A}') / 2}.
#'
#' @param A a matrix.
#' @param add return simply the addition
#' \eqn{\boldsymbol{A} + \boldsymbol{A}'}? Defaults to \code{FALSE}
#' @return A symmetric matrix with the same dimensions as \code{A}.
#' @examples
#' A <- matrix(rnorm(4), nrow = 2, ncol = 2)
#' polykde:::s(A)
#' @keywords internal
s <- function(A, add = FALSE) {
    .Call(`_polykde_s`, A, add)
}

#' @title Projection matrices \eqn{\boldsymbol{P}} and \eqn{\boldsymbol{A}}
#'
#' @description Computation of the projection matrices \eqn{\boldsymbol{P}}
#' and \eqn{\boldsymbol{A}}. The \eqn{jj}-block of \eqn{\boldsymbol{P}} is
#' \eqn{\boldsymbol{I}_{d_j} - \boldsymbol{x}_j \boldsymbol{x}_j'}. The
#' \eqn{jj}-block of \eqn{\boldsymbol{A}} is \eqn{(\boldsymbol{x}_j'
#' \boldsymbol{v}_j) \boldsymbol{I}_{d_j}}, \eqn{j=1,\ldots,r}.
#'
#' @param x,v row vectors of size \code{sum(d) + r}.
#' @inheritParams proj_polysph
#' @param orth return the orthogonal complement of \eqn{\boldsymbol{P}},
#' \eqn{\boldsymbol{I} - \boldsymbol{P}}? Defaults to \code{FALSE}.
#' @return A list with the matrices \eqn{\boldsymbol{P}} and
#' \eqn{\boldsymbol{A}}. Both matrices have size
#' \code{c(sum(d) + r, sum(d) + r)}.
#' @examples
#' d <- c(1, 2)
#' x <- r_unif_polysph(n = 1, d = d)
#' v <- r_unif_polysph(n = 1, d = d)
#' polykde:::AP(x = x, v = v, ind_dj = comp_ind_dj(d))
#' @keywords internal
AP <- function(x, v, ind_dj, orth = FALSE) {
    .Call(`_polykde_AP`, x, v, ind_dj, orth)
}

